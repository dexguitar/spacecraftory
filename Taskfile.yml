version: "3"

# Global project variables
vars:
  GO_VERSION: "1.25.2"
  GOLANGCI_LINT_VERSION: "v2.1.5"
  GCI_VERSION: "v0.13.6"
  GOFUMPT_VERSION: "v0.8.0"
  BUF_VERSION: "1.53.0"
  PROTOC_GEN_GO_VERSION: "v1.36.6"
  PROTOC_GEN_GO_GRPC_VERSION: "v1.5.1"
  PROTOC_GEN_GRPC_GATEWAY_VERSION: "v2.27.3"
  PROTOC_GEN_VALIDATE_VERSION: "v1.2.1"
  PROTOC_GEN_OPENAPIV2_VERSION: 'v2.26.3'
  OGEN_VERSION: "v1.16.0"
  YQ_VERSION: "v4.45.2"
  GRPCURL_VERSION: "v1.9.3"

  BIN_DIR: "{{.ROOT_DIR}}/bin"
  GOLANGCI_LINT: "{{.BIN_DIR}}/golangci-lint"
  GCI: "{{.BIN_DIR}}/gci"
  GOFUMPT: "{{.BIN_DIR}}/gofumpt"
  BUF: "{{.BIN_DIR}}/buf"
  OGEN: "{{.BIN_DIR}}/ogen"
  YQ: "{{.BIN_DIR}}/yq"
  PROTOC_GEN_GO: "{{.BIN_DIR}}/protoc-gen-go"
  PROTOC_GEN_GO_GRPC: "{{.BIN_DIR}}/protoc-gen-go-grpc"
  PROTOC_GEN_GRPC_GATEWAY: "{{.BIN_DIR}}/protoc-gen-grpc-gateway"
  PROTOC_GEN_VALIDATE: "{{.BIN_DIR}}/protoc-gen-validate"
  PROTOC_GEN_OPENAPIV2: "{{.BIN_DIR}}/protoc-gen-openapiv2"
  GRPCURL: "{{.BIN_DIR}}/grpcurl"

  NODE_MODULES_DIR: "{{.ROOT_DIR}}/node_modules/.bin"
  REDOCLY: "{{.NODE_MODULES_DIR}}/redocly"

  OPEN_API_ORDER_V1_BASE: "{{.ROOT_DIR}}/shared/api/order/v1/order.openapi.yaml"
  OPEN_API_ORDER_V1_BUNDLE: "{{.ROOT_DIR}}/shared/api/bundles/order.openapi.v1.bundle.yaml"

  OPEN_API_FILES: "{{.ROOT_DIR}}/shared/api/bundles"

  MODULES: assembly inventory order payment platform iam notification

tasks:
  install-formatters:
    desc: "Installs gci and gofumpt formatters in ./bin"
    summary: |
      This task checks for the presence of gofumpt and gci code formatting tools in the bin directory.
      If the tools are not found, they will be automatically installed with the specified versions.

      Used tools:
        - gofumpt: for Go code formatting
        - gci: for sorting Go imports
    cmds:
      - |
        [ -f {{.GOFUMPT}} ] || {
          echo 'üì¶ Installing gofumpt {{.GOFUMPT_VERSION}}...'
          GOBIN={{.BIN_DIR}} go install mvdan.cc/gofumpt@{{.GOFUMPT_VERSION}}
        }
        [ -f {{.GCI}} ] || {
          echo 'üì¶ Installing gci {{.GCI_VERSION}}...'
          GOBIN={{.BIN_DIR}} go install github.com/daixiang0/gci@{{.GCI_VERSION}}
        }
    status:
      - test -x {{.GOFUMPT}}
      - test -x {{.GCI}}

  format:
    desc: "Formats entire project with gofumpt + gci, excluding mocks"
    summary: |
      Formats all Go files in the project using gofumpt for code standardization
      and gci for import sorting, excluding files in mocks directories.

      Uses tools:
        - gofumpt: for standardizing formatting
        - gci: for sorting imports by standard groups
    deps: [install-formatters]
    cmds:
      - |
        echo "üßº Formatting with gofumpt..."

        for module in {{.MODULES}}; do
          if [ -d "$module" ]; then
            echo "üßº Formatting $module"
            find $module -type f -name '*.go' ! -path '*/mocks/*' -exec {{.GOFUMPT}} -extra -w {} +
          fi
        done
      - |
        echo "üéØ Sorting imports with gci..."

        for module in {{.MODULES}}; do
          if [ -d "$module" ]; then
            echo "üéØ Sorting imports in $module"
            find $module -type f -name '*.go' ! -path '*/mocks/*' -exec {{.GCI}} write -s standard -s default -s "prefix(github.com/dexguitar/spacecraftory)" {} +
          fi
        done

  install-golangci-lint:
    desc: "Installs golangci-lint in bin directory"
    summary: |
      Checks for the presence of golangci-lint in the bin directory.
      If the tool is not found, automatically installs it via go install.

      Installing version: {{.GOLANGCI_LINT_VERSION}}
    cmds:
      - |
        [ -f {{.GOLANGCI_LINT}} ] || {
          mkdir -p {{.BIN_DIR}}
          echo "üì¶ Installing golangci-lint {{.GOLANGCI_LINT_VERSION}}..."
          GOBIN={{.BIN_DIR}} go install github.com/golangci/golangci-lint/v2/cmd/golangci-lint@{{.GOLANGCI_LINT_VERSION}}
        }
    status:
      - test -x {{.GOLANGCI_LINT}}

  lint:
    desc: "Runs golangci-lint for all modules"
    summary: |
      Runs golangci-lint linter for all project modules.
      The linter checks code for compliance with quality standards and best practices.
      Checking includes security check via gosec (built into golangci-lint).

      Dependencies:
        - install-golangci-lint: automatically installs the linter
        - format: formats code before checking
    deps: [install-golangci-lint]
    vars:
      MODULES: "{{.MODULES}}"
      GOLANGCI_LINT: "{{.GOLANGCI_LINT}}"
    cmds:
      - |
        set -e
        ERR=0
        echo "üîç Linting all modules..."
        for mod in {{.MODULES}}; do
          if [ -d "$mod" ]; then
            echo "üîç Linting $mod module"
            {{.GOLANGCI_LINT}} run $mod/... --config=.golangci.yml || ERR=1
          fi
        done
        exit $ERR

  install-buf:
    desc: "Installs Buf in bin directory"
    cmds:
      - |
        [ -f {{.BUF}} ] || {
          mkdir -p {{.BIN_DIR}} tmp-buf
          curl -sSL \
            "https://github.com/bufbuild/buf/releases/download/v{{.BUF_VERSION}}/buf-$(uname -s)-$(uname -m).tar.gz" \
            | tar -xz -C tmp-buf
          mv tmp-buf/buf/bin/buf {{.BUF}}
          rm -rf tmp-buf
          chmod +x {{.BUF}}
        }

  proto:install-plugins:
    desc: "Installs protoc plugins in bin directory"
    cmds:
      - |
        [ -f {{.PROTOC_GEN_GO}} ] || {
          echo 'üì¶ Installing protoc-gen-go...'
          GOBIN={{.BIN_DIR}} go install google.golang.org/protobuf/cmd/protoc-gen-go@{{.PROTOC_GEN_GO_VERSION}}
        }
        [ -f {{.PROTOC_GEN_GO_GRPC}} ] || {
          echo 'üì¶ Installing protoc-gen-go-grpc...'
          GOBIN={{.BIN_DIR}} go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@{{.PROTOC_GEN_GO_GRPC_VERSION}}
        }
        [ -f {{.PROTOC_GEN_GRPC_GATEWAY}} ] || {
          echo 'üì¶ Installing protoc-gen-grpc-gateway...'
          GOBIN={{.BIN_DIR}} go install github.com/grpc-ecosystem/grpc-gateway/v2/protoc-gen-grpc-gateway@{{.PROTOC_GEN_GRPC_GATEWAY_VERSION}}
        }
        [ -f {{.PROTOC_GEN_VALIDATE}} ] || {
          echo 'üì¶ Installing protoc-gen-validate...'
          GOBIN={{.BIN_DIR}} go install github.com/envoyproxy/protoc-gen-validate@{{.PROTOC_GEN_VALIDATE_VERSION}}
        }
        [ -f {{.PROTOC_GEN_OPENAPIV2}} ] || {
          echo 'üì¶ Installing protoc-gen-openapiv2...'
          GOBIN={{.BIN_DIR}} go install github.com/grpc-ecosystem/grpc-gateway/v2/protoc-gen-openapiv2@{{.PROTOC_GEN_OPENAPIV2_VERSION}}
        }

  proto:gen:
    deps: [install-buf, proto:install-plugins, proto:update-deps, proto:lint]
    desc: Generate Go code from .proto
    dir: shared/proto
    cmds:
      - "{{.BUF}} generate"

  proto:update-deps:
    deps: [install-buf]
    desc: Update dependencies in .proto files
    dir: shared/proto
    cmds:
      - "{{.BUF}} dep update"

  proto:lint:
    deps: [install-buf, proto:install-plugins]
    desc: Check .proto files for style compliance
    dir: shared/proto
    cmds:
      - "{{.BUF}} lint"

  redocly-cli:install:
    desc: Install Redocly CLI locally
    cmds:
      - |
        [ -f {{.REDOCLY}} ] || {
          npm ci
        } || {
          echo "üì¶ Installing redocly-cli..."
          npm install
        }

  redocly-cli:order-v1-bundle:
    desc: Bundle OpenAPI into a single file via local redocly
    deps: [redocly-cli:install]
    cmds:
      - "{{.REDOCLY}} bundle {{.OPEN_API_ORDER_V1_BASE}} -o {{.OPEN_API_ORDER_V1_BUNDLE}}"

  redocly-cli:bundle:
    desc: Bundle all OpenAPI schemas into common files via local redocly
    deps: [redocly-cli:install]
    cmds:
      - task: redocly-cli:order-v1-bundle

  ogen:install:
    desc: "Downloads ogen to bin folder"
    cmds:
      - |
        [ -f {{.OGEN}} ] || {
          mkdir -p {{.BIN_DIR}}
          GOBIN={{.BIN_DIR}} go install github.com/ogen-go/ogen/cmd/ogen@{{.OGEN_VERSION}}
        }

  ogen:gen:
    desc: "Generate Go code from all OpenAPI declarations with x-ogen"
    deps: [ogen:install, yq:install]
    cmds:
      - task: redocly-cli:bundle
      - |
        find {{.OPEN_API_FILES}} -name '*.yaml' -o -name '*.yml' | while read -r file; do
          if [ -f "$file" ] && grep -q 'x-ogen:' "$file"; then
            echo "üöÄ Generating from: $file"
            target=$({{.YQ}} e '."x-ogen".target' "$file")
            package=$({{.YQ}} e '."x-ogen".package' "$file")
            echo "üìÅ Target: $target"
            echo "üì¶ Package: $package"
            {{.OGEN}} \
              --target "$target" \
              --package "$package" \
              --clean \
              "$file" || exit 1
          fi
        done

  gen:
    desc: "Generate all proto and OpenAPI declarations"
    cmds:
      - task: proto:gen
      - task: ogen:gen

  deps:update:
    desc: "Update dependencies in go.mod in all modules"
    cmds:
      - |
        echo "üîÑ Updating dependencies in go.mod in all modules"
        for mod in {{.MODULES}}; do
          if [ -d "$mod" ]; then
            echo "üîÑ Updating dependencies in $mod"
            (cd "$mod" && go mod tidy -compat=1.25.2) || exit 1
          fi
        done

  yq:install:
    desc: "Installs yq in bin/ when needed"
    cmds:
      - |
        [ -f {{.YQ}} ] || {
          echo 'üì¶ Installing yq...'
          GOBIN={{.BIN_DIR}} go install github.com/mikefarah/yq/v4@{{.YQ_VERSION}}
        }

  grpcurl:install:
    desc: "Installs grpcurl in bin directory"
    cmds:
      - |
        [ -f {{.GRPCURL}} ] || {
          echo 'üì¶ Installing grpcurl {{.GRPCURL_VERSION}}...'
          GOBIN={{.BIN_DIR}} go install github.com/fullstorydev/grpcurl/cmd/grpcurl@{{.GRPCURL_VERSION}}
        }
    status:
      - test -x {{.GRPCURL}}

  test-api:
    desc: "üß™ Run tests to check microservices API"
    deps: [grpcurl:install]
    cmds:
      - |
        echo "üß™ Testing microservices API via gRPC and REST"

        echo "üì¶ Test 1: Get list of parts from Inventory"
        PARTS_RESPONSE=$({{.GRPCURL}} -plaintext -d '{"filter":{}}' localhost:50051 inventory.v1.InventoryService/ListParts)

        if [[ -z "$PARTS_RESPONSE" || "$PARTS_RESPONSE" == *"error"* ]]; then
          echo "‚ùå Failed to get list of parts."
          echo "üîç Server response: $PARTS_RESPONSE"
          exit 1
        fi

        # Extract UUID of the first part for further tests
        PART_UUID=$(echo $PARTS_RESPONSE | grep -o '"uuid": "[^"]*' | head -1 | cut -d'"' -f4)
        if [ -z "$PART_UUID" ]; then
          echo "‚ùå Failed to find part UUID in response."
          echo "üîç Server response: $PARTS_RESPONSE"
          exit 1
        fi
        echo "‚úÖ Successfully got list of parts, first UUID: $PART_UUID"

        echo
        echo "üîç Test 2: Get part information by UUID"
        PART_RESPONSE=$({{.GRPCURL}} -plaintext -d "{\"uuid\":\"$PART_UUID\"}" localhost:50051 inventory.v1.InventoryService/GetPart)

        if [[ -z "$PART_RESPONSE" || "$PART_RESPONSE" == *"error"* ]]; then
          echo "‚ùå Failed to get part information."
          echo "üîç Server response: $PART_RESPONSE"
          exit 1
        fi

        # Extract part name
        PART_NAME=$(echo $PART_RESPONSE | grep -o '"name": "[^"]*' | cut -d'"' -f4)
        if [ -z "$PART_NAME" ]; then
          echo "‚ùå Failed to extract part name from response."
          echo "üîç Server response: $PART_RESPONSE"
          exit 1
        fi
        echo "‚úÖ Successfully got part: $PART_NAME"

        echo
        echo "üë§ Test 3: Create user for tests"
        # Generate unique UUID for user
        USER_UUID=$(uuidgen | tr '[:upper:]' '[:lower:]')
        echo "‚úÖ Generated user UUID: $USER_UUID"

        echo
        echo "üìù Test 4: Create order (REST API)"
        ORDER_RESPONSE=$(curl -s -X POST "http://localhost:8080/api/v1/orders" \
          -H "Content-Type: application/json" \
          -d "{\"user_uuid\":\"$USER_UUID\",\"part_uuids\":[\"$PART_UUID\"]}")

        if [[ -z "$ORDER_RESPONSE" || "$ORDER_RESPONSE" == *"error"* ]]; then
          echo "‚ùå Failed to create order."
          echo "üîç Server response: $ORDER_RESPONSE"
          exit 1
        fi

        # Extract order UUID accounting for different JSON formats
        ORDER_UUID=$(echo $ORDER_RESPONSE | grep -o '"order_uuid":"[^"]*' | cut -d'"' -f4)
        if [ -z "$ORDER_UUID" ]; then
          ORDER_UUID=$(echo $ORDER_RESPONSE | grep -o '"order_uuid": "[^"]*' | cut -d'"' -f4)
          if [ -z "$ORDER_UUID" ]; then
            echo "‚ùå Failed to extract order UUID from response."
            echo "üîç Server response: $ORDER_RESPONSE"
            exit 1
          fi
        fi
        echo "‚úÖ Successfully created order with UUID: $ORDER_UUID"

        echo
        echo "üìä Test 5: Check initial order status (should be PENDING_PAYMENT)"
        ORDER_INFO_RESPONSE=$(curl -s -X GET "http://localhost:8080/api/v1/orders/$ORDER_UUID")

        if [[ -z "$ORDER_INFO_RESPONSE" || "$ORDER_INFO_RESPONSE" == *"error"* ]]; then
          echo "‚ùå Failed to get order information."
          echo "üîç Server response: $ORDER_INFO_RESPONSE"
          exit 1
        fi

        # Extract order status accounting for different JSON formats
        ORDER_STATUS=$(echo $ORDER_INFO_RESPONSE | grep -o '"status":"[^"]*' | cut -d'"' -f4)
        if [ -z "$ORDER_STATUS" ]; then
          ORDER_STATUS=$(echo $ORDER_INFO_RESPONSE | grep -o '"status": "[^"]*' | cut -d'"' -f4)
          if [ -z "$ORDER_STATUS" ]; then
            echo "‚ùå Failed to extract order status from response."
            echo "üîç Server response: $ORDER_INFO_RESPONSE"
            exit 1
          fi
        fi

        # Check that initial status is PENDING_PAYMENT
        if [[ "$ORDER_STATUS" != *"PENDING_PAYMENT"* ]]; then
          echo "‚ùå Invalid initial order status. Expected PENDING_PAYMENT, got: $ORDER_STATUS"
          exit 1
        fi
        echo "‚úÖ Initial order status is correct: $ORDER_STATUS"

        echo
        echo "üí∞ Test 6: Pay for order (REST API)"
        PAY_RESPONSE=$(curl -s -X POST "http://localhost:8080/api/v1/orders/$ORDER_UUID/pay" \
          -H "Content-Type: application/json" \
          -d "{\"payment_method\":\"CARD\"}")

        if [[ "$PAY_RESPONSE" == *"error"* ]]; then
          echo "‚ùå Error paying for order."
          echo "üîç Server response: $PAY_RESPONSE"
          exit 1
        fi
        echo "‚úÖ Order paid successfully"

        echo
        echo "üìä Test 7: Check status after payment (should be PAID)"
        ORDER_INFO_RESPONSE=$(curl -s -X GET "http://localhost:8080/api/v1/orders/$ORDER_UUID")

        # Extract order status
        ORDER_STATUS=$(echo $ORDER_INFO_RESPONSE | grep -o '"status":"[^"]*' | cut -d'"' -f4)
        if [ -z "$ORDER_STATUS" ]; then
          ORDER_STATUS=$(echo $ORDER_INFO_RESPONSE | grep -o '"status": "[^"]*' | cut -d'"' -f4)
        fi

        # Check that status became PAID
        if [[ "$ORDER_STATUS" != *"PAID"* && "$ORDER_STATUS" != *"ASSEMBLED"* ]]; then
          echo "‚ùå Invalid order status after payment. Expected PAID or ASSEMBLED, got: $ORDER_STATUS"
          exit 1
        fi
        echo "‚úÖ Order status after payment: $ORDER_STATUS"

        echo
        echo "üìù Test 8: Create second order for cancellation (REST API)"
        ORDER2_RESPONSE=$(curl -s -X POST "http://localhost:8080/api/v1/orders" \
          -H "Content-Type: application/json" \
          -d "{\"user_uuid\":\"$USER_UUID\",\"part_uuids\":[\"$PART_UUID\"]}")

        if [[ -z "$ORDER2_RESPONSE" || "$ORDER2_RESPONSE" == *"error"* ]]; then
          echo "‚ùå Failed to create second order."
          echo "üîç Server response: $ORDER2_RESPONSE"
          exit 1
        fi

        # Extract second order UUID accounting for different JSON formats
        ORDER2_UUID=$(echo $ORDER2_RESPONSE | grep -o '"order_uuid":"[^"]*' | cut -d'"' -f4)
        if [ -z "$ORDER2_UUID" ]; then
          ORDER2_UUID=$(echo $ORDER2_RESPONSE | grep -o '"order_uuid": "[^"]*' | cut -d'"' -f4)
          if [ -z "$ORDER2_UUID" ]; then
            echo "‚ùå Failed to extract second order UUID from response."
            echo "üîç Server response: $ORDER2_RESPONSE"
            exit 1
          fi
        fi
        echo "‚úÖ Successfully created second order with UUID: $ORDER2_UUID"

        # Check its initial status
        ORDER2_INFO=$(curl -s -X GET "http://localhost:8080/api/v1/orders/$ORDER2_UUID")
        ORDER2_STATUS=$(echo $ORDER2_INFO | grep -o '"status":"[^"]*' | cut -d'"' -f4)
        if [ -z "$ORDER2_STATUS" ]; then
          ORDER2_STATUS=$(echo $ORDER2_INFO | grep -o '"status": "[^"]*' | cut -d'"' -f4)
        fi

        if [[ "$ORDER2_STATUS" != *"PENDING_PAYMENT"* ]]; then
          echo "‚ùå Invalid initial status for second order. Expected PENDING_PAYMENT, got: $ORDER2_STATUS"
          exit 1
        fi
        echo "‚úÖ Initial status of second order: $ORDER2_STATUS"

        echo
        echo "‚ùå Test 9: Cancel second order (REST API)"
        echo "Waiting 2 seconds before cancellation..."
        sleep 2

        curl -s -X POST "http://localhost:8080/api/v1/orders/$ORDER2_UUID/cancel"

        echo "Checking status after cancellation..."

        ORDER2_INFO=$(curl -s -X GET "http://localhost:8080/api/v1/orders/$ORDER2_UUID")
        ORDER2_STATUS=$(echo $ORDER2_INFO | grep -o '"status":"[^"]*' | cut -d'"' -f4)
        if [ -z "$ORDER2_STATUS" ]; then
          ORDER2_STATUS=$(echo $ORDER2_INFO | grep -o '"status": "[^"]*' | cut -d'"' -f4)
        fi

        if [[ "$ORDER2_STATUS" != *"CANCELLED"* ]]; then
          echo "‚ùå Invalid status for cancelled order. Expected CANCELLED, got: $ORDER2_STATUS"
          echo "üîç Order details: $ORDER2_INFO"
          exit 1
        fi
        echo "‚úÖ Status of second order after cancellation: $ORDER2_STATUS"

        echo
        echo "üéâ All API tests completed successfully!"
