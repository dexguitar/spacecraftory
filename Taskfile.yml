version: "3"

# Global project variables
vars:
  GO_VERSION: "1.25.2"
  GOLANGCI_LINT_VERSION: "v2.1.5"
  GCI_VERSION: "v0.13.6"
  GOFUMPT_VERSION: "v0.8.0"
  BUF_VERSION: "1.53.0"
  PROTOC_GEN_GO_VERSION: "v1.36.6"
  PROTOC_GEN_GO_GRPC_VERSION: "v1.5.1"
  PROTOC_GEN_GRPC_GATEWAY_VERSION: "v2.27.3"
  PROTOC_GEN_VALIDATE_VERSION: "v1.2.1"
  PROTOC_GEN_OPENAPIV2_VERSION: 'v2.26.3'
  OGEN_VERSION: "v1.16.0"
  YQ_VERSION: "v4.45.2"
  MOCKERY_VERSION: "v2.53.3"
  GRPCURL_VERSION: "v1.9.3"
  ENVSUBST_VERSION: 'v1.4.3'

  BIN_DIR: "{{.ROOT_DIR}}/bin"
  GOLANGCI_LINT: "{{.BIN_DIR}}/golangci-lint"
  GCI: "{{.BIN_DIR}}/gci"
  GOFUMPT: "{{.BIN_DIR}}/gofumpt"
  BUF: "{{.BIN_DIR}}/buf"
  OGEN: "{{.BIN_DIR}}/ogen"
  YQ: "{{.BIN_DIR}}/yq"
  PROTOC_GEN_GO: "{{.BIN_DIR}}/protoc-gen-go"
  PROTOC_GEN_GO_GRPC: "{{.BIN_DIR}}/protoc-gen-go-grpc"
  PROTOC_GEN_GRPC_GATEWAY: "{{.BIN_DIR}}/protoc-gen-grpc-gateway"
  PROTOC_GEN_VALIDATE: "{{.BIN_DIR}}/protoc-gen-validate"
  PROTOC_GEN_OPENAPIV2: "{{.BIN_DIR}}/protoc-gen-openapiv2"
  MOCKERY: "{{.BIN_DIR}}/mockery"
  GRPCURL: "{{.BIN_DIR}}/grpcurl"
  ENVSUBST: '{{.BIN_DIR}}/envsubst'
  ENVDIR: '{{.ROOT_DIR}}/deploy/env'

  NODE_MODULES_DIR: "{{.ROOT_DIR}}/node_modules/.bin"
  REDOCLY: "{{.NODE_MODULES_DIR}}/redocly"

  OPEN_API_ORDER_V1_BASE: "{{.ROOT_DIR}}/shared/api/order/v1/order.openapi.yaml"
  OPEN_API_ORDER_V1_BUNDLE: "{{.ROOT_DIR}}/shared/api/bundles/order.openapi.v1.bundle.yaml"

  OPEN_API_FILES: "{{.ROOT_DIR}}/shared/api/bundles"
  COVERAGE_DIR: '{{.ROOT_DIR}}/coverage'
  COVERAGE_FILE: total.out
  ORDER_MIGRATIONS_DIR: './order/migrations'
  POSTGRES_DSN: 'postgres://order-service-user:order-service-password@localhost:5432/order-service?sslmode=disable'

  MODULES: assembly inventory order payment platform iam notification
  SERVICES: core,assembly,inventory,order,payment,iam,notification

tasks:
  install-formatters:
    desc: "Installs gci and gofumpt formatters in ./bin"
    summary: |
      This task checks for the presence of gofumpt and gci code formatting tools in the bin directory.
      If the tools are not found, they will be automatically installed with the specified versions.

      Used tools:
        - gofumpt: for Go code formatting
        - gci: for sorting Go imports
    cmds:
      - |
        [ -f {{.GOFUMPT}} ] || {
          echo 'üì¶ Installing gofumpt {{.GOFUMPT_VERSION}}...'
          GOBIN={{.BIN_DIR}} go install mvdan.cc/gofumpt@{{.GOFUMPT_VERSION}}
        }
        [ -f {{.GCI}} ] || {
          echo 'üì¶ Installing gci {{.GCI_VERSION}}...'
          GOBIN={{.BIN_DIR}} go install github.com/daixiang0/gci@{{.GCI_VERSION}}
        }
    status:
      - test -x {{.GOFUMPT}}
      - test -x {{.GCI}}

  format:
    desc: "Formats entire project with gofumpt + gci, excluding mocks"
    summary: |
      Formats all Go files in the project using gofumpt for code standardization
      and gci for import sorting, excluding files in mocks directories.

      Uses tools:
        - gofumpt: for standardizing formatting
        - gci: for sorting imports by standard groups
    deps: [install-formatters]
    cmds:
      - |
        echo "üßº Formatting with gofumpt..."

        for module in {{.MODULES}}; do
          if [ -d "$module" ]; then
            echo "üßº Formatting $module"
            find $module -type f -name '*.go' ! -path '*/mocks/*' -exec {{.GOFUMPT}} -extra -w {} +
          fi
        done
      - |
        echo "üéØ Sorting imports with gci..."

        for module in {{.MODULES}}; do
          if [ -d "$module" ]; then
            echo "üéØ Sorting imports in $module"
            find $module -type f -name '*.go' ! -path '*/mocks/*' -exec {{.GCI}} write -s standard -s default -s "prefix(github.com/dexguitar/spacecraftory)" {} +
          fi
        done

  install-golangci-lint:
    desc: "Installs golangci-lint in bin directory"
    summary: |
      Checks for the presence of golangci-lint in the bin directory.
      If the tool is not found, automatically installs it via go install.

      Installing version: {{.GOLANGCI_LINT_VERSION}}
    cmds:
      - |
        [ -f {{.GOLANGCI_LINT}} ] || {
          mkdir -p {{.BIN_DIR}}
          echo "üì¶ Installing golangci-lint {{.GOLANGCI_LINT_VERSION}}..."
          GOBIN={{.BIN_DIR}} go install github.com/golangci/golangci-lint/v2/cmd/golangci-lint@{{.GOLANGCI_LINT_VERSION}}
        }
    status:
      - test -x {{.GOLANGCI_LINT}}

  lint:
    desc: "Runs golangci-lint for all modules"
    summary: |
      Runs golangci-lint linter for all project modules.
      The linter checks code for compliance with quality standards and best practices.
      Checking includes security check via gosec (built into golangci-lint).

      Dependencies:
        - install-golangci-lint: automatically installs the linter
        - format: formats code before checking
    deps: [install-golangci-lint]
    vars:
      MODULES: "{{.MODULES}}"
      GOLANGCI_LINT: "{{.GOLANGCI_LINT}}"
    cmds:
      - |
        set -e
        ERR=0
        echo "üîç Linting all modules..."
        for mod in {{.MODULES}}; do
          if [ -d "$mod" ]; then
            echo "üîç Linting $mod module"
            {{.GOLANGCI_LINT}} run $mod/... --config=.golangci.yml || ERR=1
          fi
        done
        exit $ERR

  install-buf:
    desc: "Installs Buf in bin directory"
    cmds:
      - |
        [ -f {{.BUF}} ] || {
          mkdir -p {{.BIN_DIR}} tmp-buf
          curl -sSL \
            "https://github.com/bufbuild/buf/releases/download/v{{.BUF_VERSION}}/buf-$(uname -s)-$(uname -m).tar.gz" \
            | tar -xz -C tmp-buf
          mv tmp-buf/buf/bin/buf {{.BUF}}
          rm -rf tmp-buf
          chmod +x {{.BUF}}
        }

  proto:install-plugins:
    desc: "Installs protoc plugins in bin directory"
    cmds:
      - |
        [ -f {{.PROTOC_GEN_GO}} ] || {
          echo 'üì¶ Installing protoc-gen-go...'
          GOBIN={{.BIN_DIR}} go install google.golang.org/protobuf/cmd/protoc-gen-go@{{.PROTOC_GEN_GO_VERSION}}
        }
        [ -f {{.PROTOC_GEN_GO_GRPC}} ] || {
          echo 'üì¶ Installing protoc-gen-go-grpc...'
          GOBIN={{.BIN_DIR}} go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@{{.PROTOC_GEN_GO_GRPC_VERSION}}
        }
        [ -f {{.PROTOC_GEN_GRPC_GATEWAY}} ] || {
          echo 'üì¶ Installing protoc-gen-grpc-gateway...'
          GOBIN={{.BIN_DIR}} go install github.com/grpc-ecosystem/grpc-gateway/v2/protoc-gen-grpc-gateway@{{.PROTOC_GEN_GRPC_GATEWAY_VERSION}}
        }
        [ -f {{.PROTOC_GEN_VALIDATE}} ] || {
          echo 'üì¶ Installing protoc-gen-validate...'
          GOBIN={{.BIN_DIR}} go install github.com/envoyproxy/protoc-gen-validate@{{.PROTOC_GEN_VALIDATE_VERSION}}
        }
        [ -f {{.PROTOC_GEN_OPENAPIV2}} ] || {
          echo 'üì¶ Installing protoc-gen-openapiv2...'
          GOBIN={{.BIN_DIR}} go install github.com/grpc-ecosystem/grpc-gateway/v2/protoc-gen-openapiv2@{{.PROTOC_GEN_OPENAPIV2_VERSION}}
        }

  proto:gen:
    deps: [install-buf, proto:install-plugins, proto:update-deps, proto:lint]
    desc: Generate Go code from .proto
    dir: shared/proto
    cmds:
      - "{{.BUF}} generate"

  proto:update-deps:
    deps: [install-buf]
    desc: Update dependencies in .proto files
    dir: shared/proto
    cmds:
      - "{{.BUF}} dep update"

  proto:lint:
    deps: [install-buf, proto:install-plugins]
    desc: Check .proto files for style compliance
    dir: shared/proto
    cmds:
      - "{{.BUF}} lint"

  redocly-cli:install:
    desc: Install Redocly CLI locally
    cmds:
      - |
        [ -f {{.REDOCLY}} ] || {
          npm ci
        } || {
          echo "üì¶ Installing redocly-cli..."
          npm install
        }

  redocly-cli:order-v1-bundle:
    desc: Bundle OpenAPI into a single file via local redocly
    deps: [redocly-cli:install]
    cmds:
      - "{{.REDOCLY}} bundle {{.OPEN_API_ORDER_V1_BASE}} -o {{.OPEN_API_ORDER_V1_BUNDLE}}"

  redocly-cli:bundle:
    desc: Bundle all OpenAPI schemas into common files via local redocly
    deps: [redocly-cli:install]
    cmds:
      - task: redocly-cli:order-v1-bundle

  ogen:install:
    desc: "Downloads ogen to bin folder"
    cmds:
      - |
        [ -f {{.OGEN}} ] || {
          mkdir -p {{.BIN_DIR}}
          GOBIN={{.BIN_DIR}} go install github.com/ogen-go/ogen/cmd/ogen@{{.OGEN_VERSION}}
        }

  ogen:gen:
    desc: "Generate Go code from all OpenAPI declarations with x-ogen"
    deps: [ogen:install, yq:install]
    cmds:
      - task: redocly-cli:bundle
      - |
        find {{.OPEN_API_FILES}} -name '*.yaml' -o -name '*.yml' | while read -r file; do
          if [ -f "$file" ] && grep -q 'x-ogen:' "$file"; then
            echo "üöÄ Generating from: $file"
            target=$({{.YQ}} e '."x-ogen".target' "$file")
            package=$({{.YQ}} e '."x-ogen".package' "$file")
            echo "üìÅ Target: $target"
            echo "üì¶ Package: $package"
            {{.OGEN}} \
              --target "$target" \
              --package "$package" \
              --clean \
              "$file" || exit 1
          fi
        done

  gen:
    desc: "Generate all proto and OpenAPI declarations"
    cmds:
      - task: proto:gen
      - task: ogen:gen

  deps:update:
    desc: "Update dependencies in go.mod in all modules"
    cmds:
      - |
        echo "üîÑ Updating dependencies in go.mod in all modules"
        for mod in {{.MODULES}}; do
          if [ -d "$mod" ]; then
            echo "üîÑ Updating dependencies in $mod"
            (cd "$mod" && go mod tidy -compat=1.25.2) || exit 1
          fi
        done

  yq:install:
    desc: "Installs yq in bin/ when needed"
    cmds:
      - |
        [ -f {{.YQ}} ] || {
          echo 'üì¶ Installing yq...'
          GOBIN={{.BIN_DIR}} go install github.com/mikefarah/yq/v4@{{.YQ_VERSION}}
        }

  mockery:install:
    desc: "Installing mockery in ./bin"
    cmds:
      - |
        [ -f {{.MOCKERY}} ] || {
          echo 'üì¶ Installing mockery...'
          GOBIN={{.BIN_DIR}} go install github.com/vektra/mockery/v2@{{.MOCKERY_VERSION}}
        }
    status:
      - test -x {{.MOCKERY}}

  mockery:gen:
    desc: "Generate mocks for interfaces using mockery"
    deps: [ mockery:install ]
    cmds:
      - |
        echo 'üß™ Generating mocks...'
        {{.MOCKERY}}

  test-coverage:
    desc: "Tests with business logic coverage (service/repository), report for each module + total"
    cmds:
      - |
        echo "üß™ Starting coverage calculation..."
        rm -rf {{.COVERAGE_DIR}}
        mkdir -p {{.COVERAGE_DIR}}
        
        ERR=0
        for mod in {{.MODULES}}; do
          echo "üì¶ Processing module: $mod"
        
          TARGET_PKGS=$(go list ./$mod/... \
            | grep -E '/(internal/(service|repository))' \
            | grep -vE '/(mocks|testdata|pkg|api|proto|pb|cmd)' \
            | paste -sd "," -)
        
          if [ -z "$TARGET_PKGS" ]; then
            echo "‚ö†Ô∏è  No suitable packages in $mod"
            continue
          fi
        
          go test -coverpkg="$TARGET_PKGS" \
            -coverprofile={{.COVERAGE_DIR}}/$mod.out \
            -covermode=atomic \
            $(echo "$TARGET_PKGS" | tr "," " ") || ERR=1
        done
        
        if [ $ERR -ne 0 ]; then
          echo "‚ùå Errors during tests"
          exit $ERR
        fi
        
        echo
        echo "üìä Coverage for each module:"
        for mod in {{.MODULES}}; do
          OUTFILE="{{.COVERAGE_DIR}}/$mod.out"
          if [ -f "$OUTFILE" ]; then
            printf " ‚Ä¢ %s: " "$mod"
            go tool cover -func="$OUTFILE" | tail -n1
          fi
        done
        
        echo
        echo "üì¶ Merging all coverage..."
        {
          echo "mode: atomic"
          find {{.COVERAGE_DIR}} -type f -name '*.out' ! -name '{{.COVERAGE_FILE}}' \
            -exec grep -h -v "^mode:" {} +
        } > {{.COVERAGE_DIR}}/{{.COVERAGE_FILE}}
        
        echo
        echo "üßæ Total coverage for all modules:"
        go tool cover -func={{.COVERAGE_DIR}}/{{.COVERAGE_FILE}} | tail -n1

  coverage:html:
    desc: "Generate HTML coverage report and open it in the browser"
    deps: [ test-coverage ]
    cmds:
      - |
        OUTPUT={{.COVERAGE_DIR}}/coverage.html
        echo "üåê Generating HTML report..."
        go tool cover -html={{.COVERAGE_DIR}}/{{.COVERAGE_FILE}} -o $OUTPUT

        echo "üöÄ Opening $OUTPUT"
        if command -v open &> /dev/null; then
          open $OUTPUT  # macOS
        elif command -v xdg-open &> /dev/null; then
          xdg-open $OUTPUT  # Linux
        else
          echo "üìÇ Report saved in $OUTPUT (open manually)"
        fi

  test:
    desc: "Run unit tests for all modules"
    summary: |
      Run unit tests for specified modules of the project.
      You can specify specific modules through the MODULES variable.
    cmds:
      - |
        ERR=0
        for mod in {{.MODULES}}; do
          if [ -d "$mod" ]; then
            echo "üß™ Testing module $mod"
            go test -v ./$mod/... || ERR=1
          fi
        done
        exit $ERR

  up-core:
    desc: Deploy core containers
    dir: deploy/compose/core
    cmds:
      - echo "[task] üöÄ Deploying core containers"
      - docker compose up --build --detach

  down-core:
    desc: Stop and remove core containers
    dir: deploy/compose/core
    cmds:
      - echo "[task] üõë Stopping core containers"
      - docker compose down --volumes

  up-inventory:
    desc: Deploy Inventory service and all its dependencies
    dir: deploy/compose/inventory
    cmds:
      - echo "[task] üì¶ Deploying Inventory with dependencies"
      - docker compose up --build --detach

  down-inventory:
    desc: Stop and remove Inventory service and all its dependencies
    dir: deploy/compose/inventory
    cmds:
      - echo "[task] üõë Stopping Inventory with dependencies"
      - docker compose down --volumes

  up-order:
    desc: Deploy Order service and all its dependencies
    dir: deploy/compose/order
    cmds:
      - echo "[task] üì¶ Deploying Order with dependencies"
      - docker compose up --build --detach

  down-order:
    desc: Stop and remove Order service and all its dependencies
    dir: deploy/compose/order
    cmds:
      - echo "[task] üõë Stopping Order with dependencies"
      - docker compose down --volumes

  up-all:
    desc: Deploy all services one by one with dependencies
    cmds:
      - task up-core
      - task up-inventory
      - task up-order

  down-all:
    desc: Stop and remove all services one by one with dependencies
    cmds:
      - task down-core
      - task down-inventory
      - task down-order

  grpcurl:install:
    desc: "Installs grpcurl in bin directory"
    cmds:
      - |
        [ -f {{.GRPCURL}} ] || {
          echo 'üì¶ Installing grpcurl {{.GRPCURL_VERSION}}...'
          GOBIN={{.BIN_DIR}} go install github.com/fullstorydev/grpcurl/cmd/grpcurl@{{.GRPCURL_VERSION}}
        }
    status:
      - test -x {{.GRPCURL}}

  test-api:
    desc: "üß™ Run tests to check microservices API"
    deps: [grpcurl:install]
    cmds:
      - |
        echo "üß™ Testing microservices API via gRPC and REST"

        echo "üì¶ Test 1: Get list of parts from Inventory"
        PARTS_RESPONSE=$({{.GRPCURL}} -plaintext -d '{"filter":{}}' localhost:50051 inventory.v1.InventoryService/ListParts)

        if [[ -z "$PARTS_RESPONSE" || "$PARTS_RESPONSE" == *"error"* ]]; then
          echo "‚ùå Failed to get list of parts."
          echo "üîç Server response: $PARTS_RESPONSE"
          exit 1
        fi

        # Extract UUID of the first part for further tests
        PART_UUID=$(echo $PARTS_RESPONSE | grep -o '"uuid": "[^"]*' | head -1 | cut -d'"' -f4)
        if [ -z "$PART_UUID" ]; then
          echo "‚ùå Failed to find part UUID in response."
          echo "üîç Server response: $PARTS_RESPONSE"
          exit 1
        fi
        echo "‚úÖ Successfully got list of parts, first UUID: $PART_UUID"

        echo
        echo "üîç Test 2: Get part information by UUID"
        PART_RESPONSE=$({{.GRPCURL}} -plaintext -d "{\"uuid\":\"$PART_UUID\"}" localhost:50051 inventory.v1.InventoryService/GetPart)

        if [[ -z "$PART_RESPONSE" || "$PART_RESPONSE" == *"error"* ]]; then
          echo "‚ùå Failed to get part information."
          echo "üîç Server response: $PART_RESPONSE"
          exit 1
        fi

        # Extract part name
        PART_NAME=$(echo $PART_RESPONSE | grep -o '"name": "[^"]*' | cut -d'"' -f4)
        if [ -z "$PART_NAME" ]; then
          echo "‚ùå Failed to extract part name from response."
          echo "üîç Server response: $PART_RESPONSE"
          exit 1
        fi
        echo "‚úÖ Successfully got part: $PART_NAME"

        echo
        echo "üë§ Test 3: Create user for tests"
        # Generate unique UUID for user
        USER_UUID=$(uuidgen | tr '[:upper:]' '[:lower:]')
        echo "‚úÖ Generated user UUID: $USER_UUID"

        echo
        echo "üìù Test 4: Create order (REST API)"
        ORDER_RESPONSE=$(curl -s -X POST "http://localhost:8080/api/v1/orders" \
          -H "Content-Type: application/json" \
          -d "{\"user_uuid\":\"$USER_UUID\",\"part_uuids\":[\"$PART_UUID\"]}")

        if [[ -z "$ORDER_RESPONSE" || "$ORDER_RESPONSE" == *"error"* ]]; then
          echo "‚ùå Failed to create order."
          echo "üîç Server response: $ORDER_RESPONSE"
          exit 1
        fi

        # Extract order UUID accounting for different JSON formats
        ORDER_UUID=$(echo $ORDER_RESPONSE | grep -o '"order_uuid":"[^"]*' | cut -d'"' -f4)
        if [ -z "$ORDER_UUID" ]; then
          ORDER_UUID=$(echo $ORDER_RESPONSE | grep -o '"order_uuid": "[^"]*' | cut -d'"' -f4)
          if [ -z "$ORDER_UUID" ]; then
            echo "‚ùå Failed to extract order UUID from response."
            echo "üîç Server response: $ORDER_RESPONSE"
            exit 1
          fi
        fi
        echo "‚úÖ Successfully created order with UUID: $ORDER_UUID"

        echo
        echo "üìä Test 5: Check initial order status (should be PENDING_PAYMENT)"
        ORDER_INFO_RESPONSE=$(curl -s -X GET "http://localhost:8080/api/v1/orders/$ORDER_UUID")

        if [[ -z "$ORDER_INFO_RESPONSE" || "$ORDER_INFO_RESPONSE" == *"error"* ]]; then
          echo "‚ùå Failed to get order information."
          echo "üîç Server response: $ORDER_INFO_RESPONSE"
          exit 1
        fi

        # Extract order status accounting for different JSON formats
        ORDER_STATUS=$(echo $ORDER_INFO_RESPONSE | grep -o '"status":"[^"]*' | cut -d'"' -f4)
        if [ -z "$ORDER_STATUS" ]; then
          ORDER_STATUS=$(echo $ORDER_INFO_RESPONSE | grep -o '"status": "[^"]*' | cut -d'"' -f4)
          if [ -z "$ORDER_STATUS" ]; then
            echo "‚ùå Failed to extract order status from response."
            echo "üîç Server response: $ORDER_INFO_RESPONSE"
            exit 1
          fi
        fi

        # Check that initial status is PENDING_PAYMENT
        if [[ "$ORDER_STATUS" != *"PENDING_PAYMENT"* ]]; then
          echo "‚ùå Invalid initial order status. Expected PENDING_PAYMENT, got: $ORDER_STATUS"
          exit 1
        fi
        echo "‚úÖ Initial order status is correct: $ORDER_STATUS"

        echo
        echo "üí∞ Test 6: Pay for order (REST API)"
        PAY_RESPONSE=$(curl -s -X POST "http://localhost:8080/api/v1/orders/$ORDER_UUID/pay" \
          -H "Content-Type: application/json" \
          -d "{\"payment_method\":\"CARD\"}")

        if [[ "$PAY_RESPONSE" == *"error"* ]]; then
          echo "‚ùå Error paying for order."
          echo "üîç Server response: $PAY_RESPONSE"
          exit 1
        fi
        echo "‚úÖ Order paid successfully"

        echo
        echo "üìä Test 7: Check status after payment (should be PAID)"
        ORDER_INFO_RESPONSE=$(curl -s -X GET "http://localhost:8080/api/v1/orders/$ORDER_UUID")

        # Extract order status
        ORDER_STATUS=$(echo $ORDER_INFO_RESPONSE | grep -o '"status":"[^"]*' | cut -d'"' -f4)
        if [ -z "$ORDER_STATUS" ]; then
          ORDER_STATUS=$(echo $ORDER_INFO_RESPONSE | grep -o '"status": "[^"]*' | cut -d'"' -f4)
        fi

        # Check that status became PAID
        if [[ "$ORDER_STATUS" != *"PAID"* ]]; then
          echo "‚ùå Invalid order status after payment. Expected PAID, got: $ORDER_STATUS"
          exit 1
        fi
        echo "‚úÖ Order status after payment: $ORDER_STATUS"

        echo
        echo "üìù Test 8: Create second order for cancellation (REST API)"
        ORDER2_RESPONSE=$(curl -s -X POST "http://localhost:8080/api/v1/orders" \
          -H "Content-Type: application/json" \
          -d "{\"user_uuid\":\"$USER_UUID\",\"part_uuids\":[\"$PART_UUID\"]}")

        if [[ -z "$ORDER2_RESPONSE" || "$ORDER2_RESPONSE" == *"error"* ]]; then
          echo "‚ùå Failed to create second order."
          echo "üîç Server response: $ORDER2_RESPONSE"
          exit 1
        fi

        # Extract second order UUID accounting for different JSON formats
        ORDER2_UUID=$(echo $ORDER2_RESPONSE | grep -o '"order_uuid":"[^"]*' | cut -d'"' -f4)
        if [ -z "$ORDER2_UUID" ]; then
          ORDER2_UUID=$(echo $ORDER2_RESPONSE | grep -o '"order_uuid": "[^"]*' | cut -d'"' -f4)
          if [ -z "$ORDER2_UUID" ]; then
            echo "‚ùå Failed to extract second order UUID from response."
            echo "üîç Server response: $ORDER2_RESPONSE"
            exit 1
          fi
        fi
        echo "‚úÖ Successfully created second order with UUID: $ORDER2_UUID"

        # Check its initial status
        ORDER2_INFO=$(curl -s -X GET "http://localhost:8080/api/v1/orders/$ORDER2_UUID")
        ORDER2_STATUS=$(echo $ORDER2_INFO | grep -o '"status":"[^"]*' | cut -d'"' -f4)
        if [ -z "$ORDER2_STATUS" ]; then
          ORDER2_STATUS=$(echo $ORDER2_INFO | grep -o '"status": "[^"]*' | cut -d'"' -f4)
        fi

        if [[ "$ORDER2_STATUS" != *"PENDING_PAYMENT"* ]]; then
          echo "‚ùå Invalid initial status for second order. Expected PENDING_PAYMENT, got: $ORDER2_STATUS"
          exit 1
        fi
        echo "‚úÖ Initial status of second order: $ORDER2_STATUS"

        echo
        echo "‚ùå Test 9: Cancel second order (REST API)"
        echo "Waiting 2 seconds before cancellation..."
        sleep 2

        curl -s -X POST "http://localhost:8080/api/v1/orders/$ORDER2_UUID/cancel"

        echo "Checking status after cancellation..."

        ORDER2_INFO=$(curl -s -X GET "http://localhost:8080/api/v1/orders/$ORDER2_UUID")
        ORDER2_STATUS=$(echo $ORDER2_INFO | grep -o '"status":"[^"]*' | cut -d'"' -f4)
        if [ -z "$ORDER2_STATUS" ]; then
          ORDER2_STATUS=$(echo $ORDER2_INFO | grep -o '"status": "[^"]*' | cut -d'"' -f4)
        fi

        if [[ "$ORDER2_STATUS" != *"CANCELLED"* ]]; then
          echo "‚ùå Invalid status for cancelled order. Expected CANCELLED, got: $ORDER2_STATUS"
          echo "üîç Order details: $ORDER2_INFO"
          exit 1
        fi
        echo "‚úÖ Status of second order after cancellation: $ORDER2_STATUS"

        echo
        echo "üéâ All API tests completed successfully!"

  env:install-envsubst:
    desc: "–£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç envsubst –≤ bin/"
    cmds:
      - |
        [ -f {{.ENVSUBST}} ] || {
          echo "üì¶ –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º envsubst –≤–µ—Ä—Å–∏–∏ {{.ENVSUBST_VERSION}}..."
          GOBIN={{.BIN_DIR}} go install github.com/a8m/envsubst/cmd/envsubst@{{.ENVSUBST_VERSION}}
        }
        echo "‚úÖ envsubst —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω: {{.ENVSUBST}}"

  env:generate:
    desc: "–ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç .env —Ñ–∞–π–ª—ã –¥–ª—è –≤—Å–µ—Ö —Å–µ—Ä–≤–∏—Å–æ–≤ –∏–∑ —à–∞–±–ª–æ–Ω–æ–≤ –∏ –µ–¥–∏–Ω–æ–≥–æ —Ñ–∞–π–ª–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏"
    deps: [ env:install-envsubst ]
    cmds:
      - |
        ENV_FILE="{{.ENVDIR}}/.env"
        TEMPLATE_FILE="{{.ENVDIR}}/.env.template"
        SCRIPT="{{.ENVDIR}}/generate-env.sh"
        
        if [ ! -f "$ENV_FILE" ]; then
          if [ -f "$TEMPLATE_FILE" ]; then
            echo "üîÑ –§–∞–π–ª $ENV_FILE –Ω–µ –Ω–∞–π–¥–µ–Ω, —Å–æ–∑–¥–∞–µ–º –∏–∑ —à–∞–±–ª–æ–Ω–∞ $TEMPLATE_FILE"
            cp "$TEMPLATE_FILE" "$ENV_FILE"
            echo "‚úÖ –°–æ–∑–¥–∞–Ω —Ñ–∞–π–ª $ENV_FILE. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –∏ –æ—Ç—Ä–µ–¥–∞–∫—Ç–∏—Ä—É–π—Ç–µ –∑–Ω–∞—á–µ–Ω–∏—è –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏."
          else
            echo "‚ùå –®–∞–±–ª–æ–Ω $TEMPLATE_FILE –Ω–µ –Ω–∞–π–¥–µ–Ω!"
            exit 1
          fi
        fi
        
        chmod +x "$SCRIPT"
        # –ü–µ—Ä–µ–¥–∞–µ–º —Å–ø–∏—Å–æ–∫ —Å–µ—Ä–≤–∏—Å–æ–≤ –≤ –≤–∏–¥–µ —Å—Ç—Ä–æ–∫–∏ —Å —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª—è–º–∏-–∑–∞–ø—è—Ç—ã–º–∏
        export SERVICES="{{.SERVICES}}"
        ENV_SUBST={{.ENVSUBST}} "$SCRIPT"

  test-integration:
    desc: "–ó–∞–ø—É—Å–∫–∞–µ—Ç –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–æ–Ω–Ω—ã–µ —Ç–µ—Å—Ç—ã –¥–ª—è —É–∫–∞–∑–∞–Ω–Ω—ã—Ö –º–æ–¥—É–ª–µ–π"
    summary: |
      –ó–∞–ø—É—Å–∫–∞–µ—Ç –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–æ–Ω–Ω—ã–µ —Ç–µ—Å—Ç—ã –¥–ª—è –º–æ–¥—É–ª–µ–π, —É–∫–∞–∑–∞–Ω–Ω—ã—Ö —á–µ—Ä–µ–∑ –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é MODULES.
      –ò—Å–ø–æ–ª—å–∑—É–µ—Ç —Ç–µ–≥ "integration" –¥–ª—è –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏ –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–æ–Ω–Ω—ã—Ö —Ç–µ—Å—Ç–æ–≤.
    cmds:
      - |
        ERR=0
        echo "üöÄ –ó–∞–ø—É—Å–∫ –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–æ–Ω–Ω—ã—Ö —Ç–µ—Å—Ç–æ–≤ (–ø–æ —Ç–µ–≥—É integration) –¥–ª—è –º–æ–¥—É–ª–µ–π: {{.MODULES}}"
        for mod in {{.MODULES}}; do
          if [ -d "$mod" ]; then
            echo "üß™ –ü—Ä–æ–≤–µ—Ä–∫–∞ –º–æ–¥—É–ª—è $mod –Ω–∞ –Ω–∞–ª–∏—á–∏–µ –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–æ–Ω–Ω—ã—Ö —Ç–µ—Å—Ç–æ–≤"
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ —Ñ–∞–π–ª–æ–≤ —Å —Ç–µ–≥–æ–º integration
            HAS_TESTS=$(grep -r "//go:build integration" $mod --include="*.go" | wc -l)
            
            if [ "$HAS_TESTS" -eq 0 ]; then
              echo "‚ö†Ô∏è –ú–æ–¥—É–ª—å $mod –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–æ–Ω–Ω—ã—Ö —Ç–µ—Å—Ç–æ–≤ (—Å —Ç–µ–≥–æ–º integration), –ø—Ä–æ–ø—É—Å–∫–∞–µ–º"
              continue
            fi
            
            echo "‚ñ∂Ô∏è –ó–∞–ø—É—Å–∫ –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–æ–Ω–Ω—ã—Ö —Ç–µ—Å—Ç–æ–≤ –¥–ª—è $mod"
            go test -v -tags=integration ./$mod/... || ERR=1
          fi
        done
        exit $ERR